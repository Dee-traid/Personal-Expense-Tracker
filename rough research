====== Tasks ======

- Creating Database Helper logic [Done]

- creating database and database table[Done]

- creating using registration method[Done]

- creating login/passoword reset / recovery method

- creating add,view,delete and update expense[Done]

- creating add, delete and update category [Done]method

- checking for average expenses, highest, lowest expense

- Displaying report of expenses[total expense] by time,day month or year

- Filtering all  expense  by date, month and year

- Budgeting method(add budget, update budget, delete budget)[Done]


- checking if expense is above budget 

- Adding email notification messaging 

- adding calendar reminder set using google calendar

- Method to send reminder to add expense for the month every month with budget to email/sms

- Restructuring of files in mvc architecture

- Testing and deploying to github

method for budget class

- budget check



method for expense

- average expense

- filtering of expense

- expense logic to check the total expense for day month and year

- Display of expense report



    To Check budget
        - Check if budget exist using userId and category name
        - if it does not return null
        - get sum expense amount for the categoryname and the userId
        -  perform a check if the expense amount is greater than that of the budget
        - if it is throw an alert message, if it is not throw message of budget within 
        


Give me code to achieve all this task

This is a significant jump in complexity, especially moving toward MVC (Model-View-Controller) architecture. To achieve your tasks, we need to focus on Aggregations (SUM, AVG) and Date Filtering in SQL.

Below is the refactored code to handle your specific logic requirements.

1. The Budget Logic: Over-Budget Checking
This method compares the total spent in a category vs. the set budget.

PHP
class Budget {
    // ... existing properties ...

    /**
     * Checks if the total expenses for a category exceed the budget.
     * Returns true if OVER budget, false if WITHIN budget.
     */
    public static function isOverBudget(string $userId, string $categoryName): bool {
        $pdo = DatabaseHelper::getPDOInstance();

        // 1. Get the Budget Amount for this category
        $stmtB = $pdo->prepare("SELECT amount FROM Budget WHERE user_id = :uid AND category_name = :cat LIMIT 1");
        $stmtB->execute([':uid' => $userId, ':cat' => $categoryName]);
        $budget = $stmtB->fetch(PDO::FETCH_ASSOC);

        if (!$budget) return false; // No budget set, so can't be "over" it

        // 2. Get the Sum of Expenses for this category
        $stmtE = $pdo->prepare("SELECT SUM(amount) as total_spent FROM Expenses WHERE user_id = :uid AND category_name = :cat");
        $stmtE->execute([':uid' => $userId, ':cat' => $categoryName]);
        $expense = $stmtE->fetch(PDO::FETCH_ASSOC);

        $totalSpent = (float)($expense['total_spent'] ?? 0);
        $budgetAmount = (float)$budget['amount'];

        if ($totalSpent > $budgetAmount) {
            echo "⚠️ ALERT: You have exceeded your budget for $categoryName! (Spent: $totalSpent, Budget: $budgetAmount)" . PHP_EOL;
            return true;
        }

        return false;
    }
}
2. The Expense Logic: Analytics & Filtering
These methods handle your tasks for Average, Highest, Lowest, and Time-based filtering.

PHP
class Expense {
    // ... existing properties ...

    /**
     * Gets Stats: Average, Highest, and Lowest expenses for a user
     */
    public static function getExpenseStats(string $userId) {
        $pdo = DatabaseHelper::getPDOInstance();
        $query = "SELECT 
                    AVG(amount) as average_expense, 
                    MAX(amount) as highest_expense, 
                    MIN(amount) as lowest_expense,
                    SUM(amount) as total_expense
                  FROM Expenses WHERE user_id = :uid";
        
        $stmt = $pdo->prepare($query);
        $stmt->execute([':uid' => $userId]);
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }

    /**
     * Filter expenses by specific Date, Month, or Year
     */
    public static function filterExpenses(string $userId, ?string $year = null, ?string $month = null, ?string $day = null) {
        $pdo = DatabaseHelper::getPDOInstance();
        
        $query = "SELECT * FROM Expenses WHERE user_id = :uid";
        $params = [':uid' => $userId];

        if ($year) {
            $query .= " AND EXTRACT(YEAR FROM date) = :year";
            $params[':year'] = $year;
        }
        if ($month) {
            $query .= " AND EXTRACT(MONTH FROM date) = :month";
            $params[':month'] = $month;
        }
        if ($day) {
            $query .= " AND EXTRACT(DAY FROM date) = :day";
            $params[':day'] = $day;
        }

        $stmt = $pdo->prepare($query);
        $stmt->execute($params);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    /**
     * Generates a summary report by period (day, month, year)
     */
    public static function getReportByPeriod(string $userId, string $period = 'month') {
        $pdo = DatabaseHelper::getPDOInstance();
        
        // Grouping logic for PostgreSQL
        $format = ($period === 'day') ? 'YYYY-MM-DD' : (($period === 'year') ? 'YYYY' : 'YYYY-MM');
        
        $query = "SELECT TO_CHAR(date, '$format') as period, SUM(amount) as total 
                  FROM Expenses 
                  WHERE user_id = :uid 
                  GROUP BY period 
                  ORDER BY period DESC";

        $stmt = $pdo->prepare($query);
        $stmt->execute([':uid' => $userId]);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
}
3. Implementation Example
Here is how you would call these new methods in your main script:

PHP
$userId = '6945624a79073';

// 1. Check Budget Status
$isOver = Budget::isOverBudget($userId, 'Drinks');

// 2. Get General Stats
$stats = Expense::getExpenseStats($userId);
echo "Average Spend: " . $stats['average_expense'] . PHP_EOL;

// 3. Get Monthly Report
$report = Expense::getReportByPeriod($userId, 'month');
foreach ($report as $row) {
    echo "Period: {$row['period']} | Total Spent: {$row['total']}" . PHP_EOL;
}

// 4. Filter for specific date (e.g., December 2025)
$filtered = Expense::filterExpenses($userId, '2025', '12');




Strategy for MVC Restructuring
To finish your task list, you should move toward a folder structure like this:

/app

/Models: (User.php, Expense.php, Budget.php — Data only)

/Controllers: (ExpenseController.php — Logic & Decision making)

/Repositories: (ExpenseRepository.php — SQL Queries)

/config: (DatabaseHelper.php)

index.php: (Entry point)

Would you like me to help you move these methods into a dedicated ExpenseController to start your MVC transition?

The user cli helper methods, like getting input validating input and storing input for all the which can be used in all the classes

To build a professional CLI application, you shouldn't have readline() scattered all over your classes. Instead, you should create a Trait or a Dedicated CLI Helper Class.

Since you are moving toward MVC architecture, a dedicated helper class is best. This class will handle input, validation, and output formatting (like colors or tables) for all your other classes.

1. The CLI Helper Class
This class uses a "static" approach so you can call it from anywhere without instantiating it.

PHP
class CLIHelper {
    
    /**
     * Get input from user with an optional default value
     */
    public static function getInput(string $prompt, bool $required = true): string {
        while (true) {
            echo $prompt . ": ";
            $input = trim(fgets(STDIN));

            if ($required && $input === "") {
                self::error("This field is required.");
                continue;
            }
            return $input;
        }
    }

    /**
     * Validates that input is a valid float/number (for Income/Expenses)
     */
    public static function getAmount(string $prompt): float {
        while (true) {
            $input = self::getInput($prompt);
            if (is_numeric($input) && (float)$input >= 0) {
                return (float)$input;
            }
            self::error("Invalid amount. Please enter a positive number.");
        }
    }

    /**
     * Specifically for Date inputs (YYYY-MM-DD)
     */
    public static function getDate(string $prompt, string $default = 'now'): string {
        while (true) {
            echo "$prompt (YYYY-MM-DD) [Default: $default]: ";
            $input = trim(fgets(STDIN));
            
            if ($input === "") return (new DateTime($default))->format('Y-m-d');
            
            $d = DateTime::createFromFormat('Y-m-d', $input);
            if ($d && $d->format('Y-m-d') === $input) {
                return $input;
            }
            self::error("Invalid date format. Use YYYY-MM-DD.");
        }
    }

    /**
     * Success and Error Styling
     */
    public static function success(string $message) {
        echo "\n✅ SUCCESS: $message\n";
    }

    public static function error(string $message) {
        echo "\n❌ ERROR: $message\n";
    }

    /**
     * Displays data in a simple table format
     */
    public static function displayTable(array $headers, array $rows) {
        $mask = "|";
        foreach ($headers as $header) { $mask .= " %-18.18s |"; }
        $mask .= "\n";

        echo str_repeat("-", (count($headers) * 22)) . "\n";
        printf($mask, ...$headers);
        echo str_repeat("-", (count($headers) * 22)) . "\n";

        foreach ($rows as $row) {
            printf($mask, ...array_values($row));
        }
        echo str_repeat("-", (count($headers) * 22)) . "\n";
    }
}


2. How to use it in your Tasks
Now, your registration or expense adding logic becomes much cleaner.

Example: Registering a User via CLI
PHP
// In your main prototype.php or a Controller
echo "=== USER REGISTRATION ===\n";

$name    = CLIHelper::getInput("Enter Username");
$email   = CLIHelper::getInput("Enter Email");
$phone   = CLIHelper::getInput("Enter Phone");
$pass    = CLIHelper::getInput("Enter Password");
$income  = CLIHelper::getAmount("Enter Monthly Income");

User::user_registration($name, $email, $phone, password_hash($pass, PASSWORD_DEFAULT), $income);
CLIHelper::success("User $name registered successfully!");
Example: Viewing Expenses in a Table
PHP
$expenses = Expense::ViewAllExpenses($userId);

// Transform objects/arrays into simple display rows
$displayRows = array_map(function($e) {
    return [
        'ID' => substr($e->getID(), 0, 8), // shorten ID for display
        'Name' => $e->getExpenseName(),
        'Amount' => $e->getAmount(),
        'Date' => $e->getCreatedAt()->format('Y-m-d')
    ];
}, $expenses);

CLIHelper::displayTable(['ID', 'Name', 'Amount', 'Date'], $displayRows);
3. MVC Structure Suggestion (The "Next Step")
As you requested "Restructuring of files in MVC architecture," here is how your folder structure should look to host these helpers:

/src/Models/: Put User.php, Expense.php, Budget.php (remove CLI echoes from here).

/src/Helpers/: Put CLIHelper.php and DatabaseHelper.php.

/src/Controllers/: Create an ExpenseController.php that uses CLIHelper to get input and Expense Model to save data.

main.php: Your entry point that shows the menu.

Would you like me to generate the main.php entry point script with a menu system (Switch/Case) that ties all these helper methods together?

- Adding email notification messaging 

- adding calendar reminder set using google calendar

- Method to send reminder to add expense for the month every month with budget to email/sms

To achieve these external integrations (Email, SMS, and Google Calendar), you need to move beyond standard PHP and utilize APIs and libraries.

Because your project is a CLI tool, we will use PHPMailer for emails and Google Client Services for the calendar.

1. Email Notification System (using PHPMailer)
For sending monthly reminders or "Over Budget" alerts, PHPMailer is the industry standard.

PHP
// You would typically install this via: composer require phpmailer/phpmailer
use PHPMailer\PHPMailer\PHPMailer;
use PHPMailer\PHPMailer\Exception;

class NotificationService {
    public static function sendEmail(string $to, string $subject, string $body) {
        $mail = new PHPMailer(true);
        try {
            $mail->isSMTP();
            $mail->Host       = 'smtp.gmail.com'; // Use your SMTP provider
            $mail->SMTPAuth   = true;
            $mail->Username   = 'your-email@gmail.com'; 
            $mail->Password   = 'your-app-password'; // Google App Password
            $mail->SMTPSecure = PHPMailer::ENCRYPTION_STARTTLS;
            $mail->Port       = 587;

            $mail->setFrom('tracker@expense.com', 'Expense Tracker');
            $mail->addAddress($to);
            $mail->isHTML(true);
            $mail->Subject = $subject;
            $mail->Body    = $body;

            $mail->send();
            return true;
        } catch (Exception $e) {
            error_log("Email failed: {$mail->ErrorInfo}");
            return false;
        }
    }
}
2. Google Calendar Integration
To set reminders, you need a Google Cloud Project and an oauth-credentials.json file.

PHP
// Requires: composer require google/apiclient
class CalendarService {
    public static function addReminder($summary, $date) {
        $client = new Google\Client();
        $client->setAuthConfig('credentials.json');
        $client->addScope(Google\Service\Calendar::CALENDAR);
        
        $service = new Google\Service\Calendar($client);
        $event = new Google\Service\Calendar\Event([
            'summary' => $summary,
            'description' => 'Reminder from your Expense Tracker App',
            'start' => ['date' => $date],
            'end' => ['date' => $date],
            'reminders' => [
                'useDefault' => FALSE,
                'overrides' => [['method' => 'email', 'minutes' => 24 * 60]],
            ],
        ]);

        $calendarId = 'primary';
        $event = $service->events->insert($calendarId, $event);
        return $event->htmlLink;
    }
}
3. Automated Monthly Reminders (The Logic)
This method combines your Budget class logic with the NotificationService to send a status report.

PHP
class ReminderManager {
    public static function sendMonthlyStatus(string $userId) {
        $user = User::findOneByID($userId);
        $stats = Expense::getExpenseStats($userId);
        
        $subject = "Monthly Expense Summary - " . date('F Y');
        $message = "
            <h2>Hello, " . $user->getUserName() . "!</h2>
            <p>Your total expenses this month: <b>$" . number_format($stats['total_expense'], 2) . "</b></p>
            <p>Average daily spend: $" . number_format($stats['average_expense'], 2) . "</p>
            <br>
            <p>Don't forget to log today's expenses!</p>
        ";

        if (NotificationService::sendEmail($user->getEmail(), $subject, $message)) {
            CLIHelper::success("Monthly reminder sent to " . $user->getEmail());
        }
    }
}
4. SMS Notifications (via Twilio)
For SMS, Twilio is the most reliable API for PHP.

PHP
// Requires: composer require twilio/sdk
class SMSService {
    public static function sendSMS($to, $message) {
        $sid = "YOUR_TWILIO_SID";
        $token = "YOUR_TWILIO_TOKEN";
        $client = new Twilio\Rest\Client($sid, $token);

        $client->messages->create($to, [
            'from' => '+1234567890', 
            'body' => $message
        ]);
    }
}
How to run this automatically?
Since this is a CLI app, you can't rely on a user clicking a button to send a monthly reminder. You must use a Cron Job (Linux) or Task Scheduler (Windows).

The Workflow:

Create a script called cron_reminders.php.

Inside it, fetch all users and call ReminderManager::sendMonthlyStatus($user->getID()).

Set your system to run php C:\Expense_Tracker\cron_reminders.php on the 1st of every month.

Would you like me to write the cron_reminders.php script that loops through all your users and checks their budgets automatically?

yes

To automate these notifications, we need a script that runs independently of your main CLI menu. This script will loop through every user in your database, calculate their spending vs. budget, and fire off emails if they are in trouble or just need a monthly nudge.

1. The Automated Logic (cron_reminders.php)
This script acts as your "Background Worker."

PHP
<?php
require_once 'prototype.php'; // Load your classes
require_once 'NotificationService.php';

// 1. Fetch all users from the database
$pdo = DatabaseHelper::getPDOInstance();
$stmt = $pdo->query("SELECT id, user_name, email FROM Users");
$users = $stmt->fetchAll(PDO::FETCH_ASSOC);

echo "--- Starting Automated Reminder Service [" . date('Y-m-d H:i:s') . "] ---\n";

foreach ($users as $userData) {
    $userId = $userData['id'];
    $userName = $userData['user_name'];
    $userEmail = $userData['email'];

    echo "Processing $userName...\n";

    // 2. Check Budget Status for all categories
    $stmtB = $pdo->prepare("SELECT category_name, amount FROM Budget WHERE user_id = :uid");
    $stmtB->execute([':uid' => $userId]);
    $budgets = $stmtB->fetchAll(PDO::FETCH_ASSOC);

    foreach ($budgets as $budget) {
        $cat = $budget['category_name'];
        
        // Use your existing logic to check if they are over
        if (Budget::isOverBudget($userId, $cat)) {
            $subject = "⚠️ BUDGET ALERT: $cat";
            $message = "Hi $userName, you have exceeded your budget for $cat. Please check your expenses.";
            
            NotificationService::sendEmail($userEmail, $subject, $message);
            echo " - Alert sent for $cat\n";
        }
    }

    // 3. Monthly Summary (Run this only on the 1st of the month)
    if (date('d') === '01') {
        ReminderManager::sendMonthlyStatus($userId);
    }
}

echo "--- Reminder Service Finished ---\n";
2. Setting Up the "Trigger" (Windows/Linux)
Since you are on Windows (based on your file path C:\Expense_Tracker), you use Task Scheduler.

Open Task Scheduler and click Create Basic Task.

Trigger: Daily (at a time like 08:00 AM).

Action: Start a Program.

Program/script: php.exe (Path to your PHP executable).

Add arguments: C:\Expense_Tracker\cron_reminders.php.

3. Integrating Google Calendar Reminders
To satisfy your requirement of adding a calendar reminder to "add expenses," you can add this method to your User registration or Budget creation logic:

PHP
public static function scheduleMonthlyReminder(string $userEmail) {
    $nextMonth = (new DateTime('first day of next month'))->format('Y-m-d');
    
    try {
        $link = CalendarService::addReminder(
            "Expense Tracker: Set your budget for the month", 
            $nextMonth
        );
        echo "Google Calendar reminder scheduled! Link: $link\n";
    } catch (Exception $e) {
        echo "Could not schedule calendar event: " . $e->getMessage() . "\n";
    }
}
Summary of your System Architecture
Now that you have all the pieces, your folder structure for the MVC Restructuring should look like this:

Folder/File	Purpose
/app/Models	User, Expense, Budget (Data structures)
/app/Services	NotificationService, CalendarService, SMSService
/app/Helpers	CLIHelper, DatabaseHelper
/cron	cron_reminders.php (The script we just wrote)
main.php	The main CLI Menu for the user
Would you like me to provide the final main.php menu script that connects the CLIHelper to all these new features (Add Expense, Check Budget, View Reports)?













To refactor the password recovery into a single, cohesive workflow, we need to bridge the gap between **identifying the user** and **securely updating their password**.

In a CLI environment, this usually involves a "Verification Code" or "Token" simulation. Below is the refactored method. I have moved the logic to be more secure (using `password_hash`) and combined the validation and update steps into one process.

### The Refactored Password Reset Method

This method is placed inside your `User` class. It handles the identification, verifies a "recovery code," and updates the database.

```php
public static function resetPassword(string $identifier) {
    $pdo = DatabaseHelper::getPDOInstance();

    // 1. Validate User Exists
    $query = "SELECT id, email FROM Users WHERE email = :identifier OR phone_number = :identifier";
    $stmt = $pdo->prepare($query);
    $stmt->execute([':identifier' => $identifier]);
    $user = $stmt->fetch(PDO::FETCH_ASSOC);

    if (!$user) {
        CLIHelper::error("No user found with that Email or Phone Number.");
        return false;
    }

    // 2. Simulate sending a recovery code (In real life, this goes to Email/SMS)
    $recoveryCode = (string)rand(100000, 999999);
    echo "\n[RECOVERY] A code has been sent to your registered device: $recoveryCode\n";

    // 3. Verify Code
    $userInput = CLIHelper::getInput("Enter the 6-digit recovery code");

    if ($userInput !== $recoveryCode) {
        CLIHelper::error("Invalid recovery code. Reset cancelled.");
        return false;
    }

    // 4. Get and Validate New Password
    $newPassword = CLIHelper::getInput("Enter your new password");
    $confirmPassword = CLIHelper::getInput("Confirm new password");

    if ($newPassword !== $confirmPassword) {
        CLIHelper::error("Passwords do not match.");
        return false;
    }

    // 5. Update Database with Hashed Password
    $hashedPassword = password_hash($newPassword, PASSWORD_DEFAULT);
    $timestamp = (new DateTimeImmutable('now'))->format('Y-m-d H:i:s');

    try {
        $updateQuery = "UPDATE Users SET password = :password, updated_at = :updated_at WHERE id = :id";
        $updateStmt = $pdo->prepare($updateQuery);
        $updateStmt->execute([
            ':password' => $hashedPassword,
            ':updated_at' => $timestamp,
            ':id' => $user['id']
        ]);

        CLIHelper::success("Password updated successfully! You can now login.");
        return true;
    } catch (PDOException $e) {
        CLIHelper::error("Database error: " . $e->getMessage());
        return false;
    }
}

```

---

### How this improves your code:

1. **Atomicity:** The process happens in one logical flow. You don't risk a user "getting a token" but having no method to actually use it.
2. **Security:** It uses `password_hash()`. Your previous code was storing strings like `"password_hash(...)"` as plain text, which makes `password_verify()` fail during login.
3. **User Experience:** It uses the `CLIHelper` we built to handle all the inputs and errors consistently.

---

### Integration into the Main Menu

When you build your `main.php` (the entry point), the Password Recovery option would look like this:

```php
case 'forgot_password':
    $identifier = CLIHelper::getInput("Enter your Email or Phone Number to recover account");
    User::resetPassword($identifier);
    break;

```

### Final Folder Structure (MVC Refined)

To keep things organized, ensure your files are separated as follows:

* **Models/User.php**: Contains the `resetPassword` and `user_registration` logic.
* **Helpers/CLIHelper.php**: Contains the `getInput`, `success`, and `error` methods.
* **Services/NotificationService.php**: (Optional) You could trigger an email from inside `resetPassword` to send the actual code.

**Would you like me to show you how to trigger the `NotificationService::sendEmail` inside this reset method so the recovery code actually gets mailed to the user?**





















To help you integrate the input methods while keeping your existing structure, I have identified a few logical gaps in your current code (like missing variables or method calls) and filled them using your CLIHelper.

Here are the updates for your classes to handle Registration, Login, and Data Management via the CLI.

1. Updated User Class
I have uncommented and fixed getUserInput() and updated userRegistration to use it. I also added a getLoginInput() helper.

PHP
class User {
    // ... existing properties and constructor ...

    public static function getUserInput() {
        $userName = CLIHelper::validateInput("Enter your Username");
        $email = CLIHelper::validateEmail("Enter your email");
        $phoneNo = CLIHelper::validatePhoneNumber("Enter your Phone number");
        $password = CLIHelper::passwordHash("Create Password");
        $income = CLIHelper::getAmount("Enter your Income");

        return [
            'userName' => $userName, 
            'email' => $email, 
            'phoneNo' => $phoneNo, 
            'password' => $password, 
            'income' => $income
        ];
    }

    public static function userRegistration() {
        $pdo = DatabaseHelper::getPDOInstance();
        // Get data from CLI
        $data = self::getUserInput();

        try {
            // Check if user exists
            $stmt = $pdo->prepare("SELECT * FROM Users WHERE email = :email OR phone_number = :phone");
            $stmt->execute([':email' => $data['email'], ':phone' => $data['phoneNo']]);
            
            if ($stmt->fetch()) {
                CLIHelper::error("User exists. Please Login");
                return null;
            }

            $id = uniqid();
            $timestamp = (new DateTimeImmutable('now'))->format('Y-m-d H:i:s');

            $query = "INSERT INTO Users(id, user_name, email, phone_number, password, income, created_at, updated_at) 
                      VALUES (:id, :user_Name, :email, :phoneNo, :password, :income, :created_at, :updated_at)";

            $stmt = $pdo->prepare($query);
            $stmt->execute([
                ':id' => $id,
                ':user_Name' => $data['userName'],
                ':email' => $data['email'],
                ':phoneNo' => $data['phoneNo'],
                ':password' => $data['password'],
                ':income' => $data['income'],
                ':created_at' => $timestamp,
                ':updated_at' => $timestamp
            ]);

            CLIHelper::success("Registration Successful!");
            return self::findOneByID($id);
        } catch(PDOException $e) {
            CLIHelper::error("Registration Failed: " . $e->getMessage());
            return null;
        }
    }

    public static function loginFromCLI() {
        $identifier = CLIHelper::getInput("Enter Email or Phone Number");
        $password = CLIHelper::getInput("Enter Password");
        return self::userLogin($identifier, $identifier, $password);
    }
}
2. Updated Category Class
Added logic to the addCategory method to actually use the inputs provided by the user.

PHP
class Category {
    // ... existing properties ...

    public static function getCategoryInput() {
        $categoryName = CLIHelper::validateInput("Enter category name");
        $description = CLIHelper::validateInput("Enter category Description");
        return ['name' => $categoryName, 'desc' => $description];
    }

    public static function addCategory() {
        $pdo = DatabaseHelper::getPDOInstance();
        $data = self::getCategoryInput();
        
        $id = uniqid();
        $timestamp = (new DateTimeImmutable('now'))->format('Y-m-d H:i:s'); 
        
        $query = "INSERT INTO categories (id, category_name, description, created_at, updated_at) 
                  VALUES (:id, :name, :desc, :created_at, :updated_at)";
        try {
            $stmt = $pdo->prepare($query);
            $stmt->execute([
                ':id' => $id,
                ':name' => $data['name'],
                ':desc' => $data['desc'],
                ':created_at' => $timestamp,
                ':updated_at' => $timestamp
            ]);
            CLIHelper::success("Category Added successfully");
        } catch(PDOException $e) {
            CLIHelper::error("Error: " . $e->getMessage());
        }   
    }
}
3. Updated Expense Class
Created a CLI flow to gather the details needed for an expense.

PHP
class Expense {
    // ... existing properties ...

    public static function addExpenseFromCLI(string $userId) {
        $categoryName = CLIHelper::validateInput("Enter Category Name");
        $expenseName = CLIHelper::validateInput("What did you buy? (Expense Name)");
        $amount = CLIHelper::getAmount("Enter Amount");
        $description = CLIHelper::getInput("Enter Description (Optional)");

        return self::AddExpense($userId, $categoryName, $expenseName, $amount, $description);
    }

    // Fixed your existing AddExpense to include the description parameter
    public static function AddExpense(string $user_id, string $category_name, string $expense_name, float $amount, string $description = "") {
        $pdo = DatabaseHelper::getPDOInstance();
        $id = uniqid('', true);
        $timestamp = (new DateTimeImmutable('Now'))->format("Y-m-d H:i:s");
        $date = (new DateTimeImmutable('Now'))->format("Y-m-d");

        try {
            $query = "INSERT INTO Expenses (id, user_id, category_name, expense_name, amount, date, description, created_at, updated_at) 
                      VALUES (:id, :user_id, :category_name, :expense_name, :amount, :date, :description, :created_at, :updated_at)";
            $stmt = $pdo->prepare($query);
            $stmt->execute([
                ':id' => $id,
                ':user_id' => $user_id,
                ':category_name' => $category_name,
                ':expense_name' => $expense_name,
                ':amount' => $amount,
                ':date' => $date,
                ':description' => $description,
                ':created_at' => $timestamp,
                ':updated_at' => $timestamp
            ]);
            CLIHelper::success("Expense added successfully");
            return self::findOneByID($id);
        } catch(PDOException $e) {
            CLIHelper::error("Error: " . $e->getMessage());
        }
    }
}
Important Fixes Applied:
Variable Scope: In your original userRegistration, variables like $userName and $email were used but not defined. I captured them from the $data array returned by getUserInput().

Logic Errors: In CLIHelper::validateInput, you used a variable $minLength which wasn't defined. I recommend setting a default (e.g., $minLength = 2).

Consistency: Updated your SQL queries to use the array execution method execute([...]) which is cleaner than multiple bindParam calls.

How to use it now:
PHP
// To Register a new user via CLI
User::userRegistration();

// To Add a category via CLI
Category::addCategory();

// To Add an expense for a specific user
Expense::addExpenseFromCLI('USER_ID_HERE');
Would you like me to create a main menu loop to link all these operations together into a functional CLI application?

do for expense and budget method

To integrate user inputs for Expense and Budget methods while keeping your structure intact, I’ve added CLI-specific "handler" methods. These methods collect the data using your CLIHelper and then pass it to your existing database logic.

1. Updated Expense Class
I added promptForExpense, which gathers all details from the user, and updated the AddExpense method to ensure it handles the description correctly.

PHP
class Expense {
    // ... (existing properties and constructor) ...

    /**
     * CLI Method to prompt user for data and save it
     */
    public static function createFromCLI(string $user_id) {
        echo "\n--- Add New Expense ---\n";
        $category_name = CLIHelper::validateInput("Enter Category (e.g., Food, Transport)");
        $expense_name  = CLIHelper::validateInput("What did you buy?");
        $amount        = CLIHelper::getAmount("How much did it cost?");
        $description   = CLIHelper::getInput("Enter a short description (Optional)");

        return self::AddExpense($user_id, $category_name, $expense_name, $amount, $description);
    }

    public static function AddExpense(string $user_id, string $category_name, string $expense_name, float $amount, string $description = "") {
        $pdo = DatabaseHelper::getPDOInstance();
        $id = uniqid('', true);
        $timestamp = (new DateTimeImmutable('now'))->format("Y-m-d H:i:s");
        $date = (new DateTimeImmutable('now'))->format("Y-m-d");

        try {
            $query = "INSERT INTO Expenses (id, user_id, category_name, expense_name, amount, date, description, created_at, updated_at) 
                      VALUES (:id, :user_id, :category_name, :expense_name, :amount, :date, :description, :created_at, :updated_at)";
            
            $stmt = $pdo->prepare($query);
            $stmt->execute([
                ':id' => $id,
                ':user_id' => $user_id,
                ':category_name' => $category_name,
                ':expense_name' => $expense_name,
                ':amount' => $amount,
                ':date' => $date,
                ':description' => $description,
                ':created_at' => $timestamp,
                ':updated_at' => $timestamp
            ]);

            CLIHelper::success("Expense added successfully!");
            return self::findOneByID($id);
        } catch (PDOException $e) {
            CLIHelper::error("Failed to add expense: " . $e->getMessage());
            return null;
        }
    }
}
2. Updated Budget Class
I fixed the logic in AddBudget to use the inputs and provided a CLI helper to handle the dates using your getDateInput method.

PHP
class Budget {
    // ... (existing properties and constructor) ...

    /**
     * CLI Method to prompt user for budget details
     */
    public static function createFromCLI(string $user_id) {
        echo "\n--- Set New Budget ---\n";
        $category_name = CLIHelper::validateInput("Enter Category for this budget");
        $amount        = CLIHelper::getAmount("Enter budget limit amount");
        $start_date    = CLIHelper::getDateInput("Enter Start Date", "now");
        $end_date      = CLIHelper::getDateInput("Enter End Date", "+1 month");

        return self::AddBudget($user_id, $category_name, $amount, $start_date, $end_date);
    }

    public static function AddBudget(string $user_id, string $category_name, float $amount, string $start_date, string $end_date) {
        $pdo = DatabaseHelper::getPDOInstance();
        $id = uniqid();
        $timestamp = (new DateTimeImmutable('now'))->format("Y-m-d H:i:s");

        try {
            $query = "INSERT INTO Budget (id, user_id, category_name, amount, start_date, end_date, created_at, updated_at) 
                      VALUES (:id, :user_id, :category_name, :amount, :start_date, :end_date, :created_at, :updated_at)";
            
            $stmt = $pdo->prepare($query);
            $stmt->execute([
                ':id' => $id,
                ':user_id' => $user_id,
                ':category_name' => $category_name,
                ':amount' => $amount,
                ':start_date' => $start_date,
                ':end_date' => $end_date,
                ':created_at' => $timestamp,
                ':updated_at' => $timestamp
            ]);

            CLIHelper::success("Budget set successfully!");
        } catch (PDOException $e) {
            CLIHelper::error("Error adding budget: " . $e->getMessage());
        }
    }
}
Key Changes Made:
Decoupling: I created createFromCLI methods. This keeps the database logic (AddExpense/AddBudget) clean so you can still use them for non-CLI purposes (like an API later), while the CLI methods handle all the echo and readline logic.

Date Handling: Used your CLIHelper::getDateInput for the Budget dates so users can just press "Enter" to accept the default current date.

Cleanup: Replaced individual bindParam calls with an array inside execute(). It is much shorter and prevents "Undefined variable" errors if a variable name is slightly mistyped.

Example Usage:
To run these from your main script, you would do this:

PHP
// Assuming you have a logged-in user ID
$currentUserId = '6945624a79073';

// Add an expense via CLI
Expense::createFromCLI($currentUserId);

// Set a budget via CLI
Budget::createFromCLI($currentUserId);
Would you like me to help you create a simple switch-case menu so the user can choose between Adding an Expense, Setting a Budget, or Viewing Stats?

give me how the overall menu should look like

To create a professional CLI experience, your main menu should run in a "While" loop so the application stays open until the user chooses to exit. It should handle the flow from logging in to performing actions like adding expenses or budgets.

Here is a clean, structured implementation of your main menu.

The Main Application Loop
PHP
function MainMenu() {
    $loggedInUser = null;

    while (true) {
        echo "\n==============================\n";
        echo "   EXPENSE TRACKER SYSTEM     \n";
        echo "==============================\n";

        if (!$loggedInUser) {
            // Unauthenticated Menu
            echo "1. Register\n";
            echo "2. Login\n";
            echo "0. Exit\n";
            $choice = CLIHelper::getInput("Choose an option");

            switch ($choice) {
                case '1':
                    $loggedInUser = User::userRegistration();
                    break;
                case '2':
                    // Using the logic: Get email/phone and password then login
                    $id = CLIHelper::getInput("Enter Email or Phone");
                    $pass = CLIHelper::getInput("Enter Password");
                    // Assuming userLogin is updated to return the User object on success
                    $loggedInUser = User::userLogin($id, $id, $pass); 
                    break;
                case '0':
                    exit("Goodbye!\n");
                default:
                    CLIHelper::error("Invalid choice.");
            }
        } else {
            // Authenticated Menu
            echo "Welcome, " . $loggedInUser->getUserName() . "!\n";
            echo "------------------------------\n";
            echo "1. Add Expense\n";
            echo "2. Set Budget\n";
            echo "3. View All Expenses\n";
            echo "4. View Expense Stats\n";
            echo "5. Add Category\n";
            echo "6. Update Profile\n";
            echo "0. Logout\n";
            $choice = CLIHelper::getInput("Choose an option");

            switch ($choice) {
                case '1':
                    Expense::createFromCLI($loggedInUser->getID());
                    break;
                case '2':
                    Budget::createFromCLI($loggedInUser->getID());
                    break;
                case '3':
                    $expenses = Expense::ViewAllExpenses($loggedInUser->getID());
                    var_dump($expenses); // You can create a Table helper for this later
                    break;
                case '4':
                    $stats = Expense::getExpenseStats($loggedInUser->getID());
                    echo "\n--- Your Stats ---\n";
                    echo "Total Spent: " . ($stats['total_expense'] ?? 0) . "\n";
                    echo "Average: " . ($stats['average_expense'] ?? 0) . "\n";
                    break;
                case '5':
                    Category::addCategory();
                    break;
                case '0':
                    $loggedInUser = null;
                    CLIHelper::success("Logged out successfully.");
                    break;
                default:
                    CLIHelper::error("Invalid choice.");
            }
        }
    }
}

// Start the app
MainMenu();
Menu Workflow Logic
Key Improvements for the Menu:
State Management: The $loggedInUser variable tracks whether someone is signed in. When it's null, the app only shows Register/Login.

Clear Visuals: Using =====, -----, and \n (newlines) makes the terminal output much easier to read for the user.

Encapsulation: By using the createFromCLI methods we built in the previous step, the menu code stays very short and readable.

Error Handling: The default case in the switch statement handles instances where a user types a letter or an invalid number.

Important Note for your User::userLogin:
For this menu to work smoothly, make sure your userLogin method returns the user object after a successful login, rather than just echoing "Login Successful."

Would you like me to help you create a "Table Helper" method to display the expenses in a clean, aligned list instead of using var_dump?


To simplify this logic, we can focus on making the code more readable, reusable, and standardized.

Below is the refactored code. I have simplified the date formatting logic and added line-by-line comments to explain exactly what is happening at every stage.

Refactored Expense Tracker Logic
PHP

class ExpenseManager {

    /**
     * Step 1: Basic Statistics
     * Calculates the average, max, min, and sum of all expenses for a user.
     */
    public static function getExpenseStats(string $userId) {
        $pdo = DatabaseHelper::getPDOInstance(); // Get the DB connection

        // Use SQL aggregate functions to calculate everything in one trip to the database
        $query = "SELECT AVG(amount) as avg, MAX(amount) as max, MIN(amount) as min, SUM(amount) as total 
                  FROM Expenses WHERE user_id = :uid";

        $stmt = $pdo->prepare($query); // Prepare the SQL statement for safety
        $stmt->execute([':uid' => $userId]); // Execute with the user ID bound to the parameter
        
        return $stmt->fetch(PDO::FETCH_ASSOC); // Return a single associative array of stats
    }

    /**
     * Step 2: Flexible Filtering
     * Uses an array-building approach to handle optional filters (Year, Month, Day).
     */
    public static function filterExpenses(string $userId, ?string $y = null, ?string $m = null, ?string $d = null) {
        $pdo = DatabaseHelper::getPDOInstance();

        // Start with the base query
        $query = "SELECT * FROM Expenses WHERE user_id = :uid";
        $params = [':uid' => $userId]; // Initialize parameter array with the User ID

        // Define a map of date parts to their SQL column extraction equivalent
        $filters = ['YEAR' => $y, 'MONTH' => $m, 'DAY' => $d];

        foreach ($filters as $part => $value) {
            if ($value) { // If a filter value (like $year) was actually provided...
                $query .= " AND EXTRACT($part FROM date) = :$part"; // Append the filter to the SQL
                $params[":$part"] = $value; // Add the value to our execution parameters
            }
        }

        $stmt = $pdo->prepare($query); // Prepare the final built string
        $stmt->execute($params); // Execute with all gathered parameters
        
        return $stmt->fetchAll(PDO::FETCH_ASSOC); // Return all matching expense rows
    }



       public static function filterExpenses(string $userId, ?string $year = null, ?string $month = null, ?string $day = null) {
        $pdo = DatabaseHelper::getPDOInstance();
        
        $query = "SELECT * FROM Expenses WHERE user_id = :uid";
        $params = [':uid' => $userId];

        if ($year) {
            $query .= " AND EXTRACT(YEAR FROM date) = :year";
            $params[':year'] = $year;
        }
        if ($month) {
            $query .= " AND EXTRACT(MONTH FROM date) = :month";
            $params[':month'] = $month;
        }
        if ($day) {
            $query .= " AND EXTRACT(DAY FROM date) = :day";
            $params[':day'] = $day;
        }

        $stmt = $pdo->prepare($query);
        $stmt->execute($params);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }


    /**
     * Step 3: Period Summaries
     * Groups expenses by a specific timeframe (Daily, Monthly, or Yearly).
     */
    public static function getReportByPeriod(string $userId, string $period = 'month') {
        $pdo = DatabaseHelper::getPDOInstance();

        // Simplify format selection using a simple lookup array
        $formats = ['day' => 'YYYY-MM-DD', 'year' => 'YYYY', 'month' => 'YYYY-MM'];
        $sqlFormat = $formats[$period] ?? 'YYYY-MM'; // Default to monthly if input is invalid

        // Select the formatted date and the sum, group by that formatted date
        $query = "SELECT TO_CHAR(date, :fmt) as period, SUM(amount) as total 
                  FROM Expenses 
                  WHERE user_id = :uid 
                  GROUP BY period 
                  ORDER BY period DESC";

        $stmt = $pdo->prepare($query);
        // Bind both the user ID and the date format string
        $stmt->execute([':uid' => $userId, ':fmt' => $sqlFormat]);
        
        return $stmt->fetchAll(PDO::FETCH_ASSOC); // Return a list of periods and their totals
    }
}
What was simplified?
Looping for Filters: Instead of three separate if statements in filterExpenses, I used a foreach loop. This makes the code shorter and easier to add more filters (like "week") later.

Lookup Arrays: In getReportByPeriod, I replaced the nested ternary operators ? : with a simple $formats array. This is much easier to read at a glance.

Parametric Formatting: I moved the date format (YYYY-MM) into a bound parameter :fmt. This is a cleaner way to pass configuration into your SQL queries.

Why use these methods?
EXTRACT: Great for pulling specific numbers (like the number 12 for December) out of a timestamp for easy comparison.

TO_CHAR: Perfect for reports because it turns a date into a pretty string (like "2023-12") which is ready to be displayed on a chart or table.

Would you like me to show you how to display these results in a clean HTML table or a CLI output?







To calculate expense by day month and year

class Expense {
    // ... existing methods ...

    /**
     * Get total expenses for a specific period
     * @param string $userId
     * @param string $period (daily, monthly, yearly)
     */

    public static function getTotalSpent(string $userId, string $period = 'monthly') {
        $pdo = DatabaseHelper::getPDOInstance();
        
        // Define the SQL condition based on the period
        switch ($period) {
            case 'daily':
                $dateCondition = "AND created_at::date = CURRENT_DATE";
                break;
            case 'yearly':
                $dateCondition = "AND EXTRACT(YEAR FROM created_at) = EXTRACT(YEAR FROM CURRENT_DATE)";
                break;
            case 'monthly':
            default:
                $dateCondition = "AND EXTRACT(MONTH FROM created_at) =

                what is the work of this last query

                 //EXTRACT(MONTH FROM CURRENT_DATE) 
                                  AND EXTRACT(YEAR FROM created_at) = EXTRACT(YEAR FROM CURRENT_DATE)";//
                break;
        }

        $query = "SELECT SUM(amount) as total FROM Expenses WHERE user_id = :userId $dateCondition";

        try {
            $stmt = $pdo->prepare($query);
            $stmt->execute([':userId' => $userId]);
            $row = $stmt->fetch(PDO::FETCH_ASSOC);
            
            return (float)($row['total'] ?? 0);
        } catch (PDOException $e) {
            CLIHelper::error("Calculation Error: " . $e->getMessage());
            return 0.0;
        }
    }

    /**
     * A helper to display a summary dashboard
     */
    public static function displaySummary(string $userId) {
        $daily = self::getTotalSpent($userId, 'daily');
        $monthly = self::getTotalSpent($userId, 'monthly');
        $yearly = self::getTotalSpent($userId, 'yearly');

        echo "\n--- EXPENSE SUMMARY ---" . PHP_EOL;
        echo "Today:      $" . number_format($daily, 2) . PHP_EOL;
        echo "This Month: $" . number_format($monthly, 2) . PHP_EOL;
        echo "This Year:  $" . number_format($yearly, 2) . PHP_EOL;
        echo "-----------------------" . PHP_EOL;
    }
}
3. How to use it in your prototype.php
Since you're working in a CLI environment, you can call this right after a user logs in:

PHP

$userId = "6951f8aec306f"; // Example ID from your previous code

// Display the dashboard
Expense::displaySummary($userId);
Why this approach is better:
Memory Efficient: If a user has 5,000 expenses, your PHP memory won't crash because you're only receiving one number (the total) back from the database.

Accuracy: Using EXTRACT or ::date ensures that time-stamps (hours/minutes/seconds) don't mess up your daily totals.

Formatting: Using number_format($total, 2) ensures your currency looks professional (e.g., $1,250.50 instead of 1250.5).

Pro-Tip for your Budget:
You can compare these totals against your Budget::getAmount() to see if the user is overspending!

























Afternoon! You’re getting into the advanced analytics part of the app now—this is where the real value is for the user.

However, your current logic has a few "variable scope" issues. In several places, you are trying to use $categoryName or $value inside your SQL, but those variables aren't defined in your function arguments or are getting overwritten in your loops.

Here are the fixes for your three methods:

1. The Stats Method (Finding the "Why" behind the numbers)
To show the Category Name for the Min/Max, you actually need a different SQL approach. SUM and AVG are easy, but for the "Highest Expense Category," you need to group them.

PHP

public static function getExpenseStats(string $userId) {
    $pdo = DatabaseHelper::getPDOInstance();

    // This query gets the overall stats for the user across ALL categories
    $query = "SELECT 
                AVG(amount) as average_expense, 
                MAX(amount) as highest_expense, 
                MIN(amount) as lowest_expense, 
                SUM(amount) as total_expense 
              FROM Expenses WHERE user_id = :uid";

    try {
        $stmt = $pdo->prepare($query);
        $stmt->execute([':uid' => $userId]);
        return $stmt->fetch(PDO::FETCH_ASSOC);
    } catch (PDOException $e) {
        CLIHelper::error("Stats Error: " . $e->getMessage());
        return null;
    }
}

2. The Filter Method (Fixing the Loop)
In your original code, $stmt->bindparam(':period', $value) only binds the last value from the loop to every placeholder. We need to bind unique names for Year, Month, and Day.

PHP

public static function filterExpenses(string $userId, ?string $year = null, ?string $month = null, ?string $day = null) {
    $pdo = DatabaseHelper::getPDOInstance();
    $query = "SELECT * FROM Expenses WHERE user_id = :userId"; 
    $params = [':userId' => $userId];

    // Add filters dynamically
    if ($year) {
        $query .= " AND EXTRACT(YEAR FROM created_at) = :year";
        $params[':year'] = $year;
    }
    if ($month) {
        $query .= " AND EXTRACT(MONTH FROM created_at) = :month";
        $params[':month'] = $month;
    }
    if ($day) {
        $query .= " AND EXTRACT(DAY FROM created_at) = :day";
        $params[':day'] = $day;
    }

    $stmt = $pdo->prepare($query);
    $stmt->execute($params);
    return $stmt->fetchAll(PDO::FETCH_ASSOC);
}
3. The Report Method (The "Big Picture")
You had a $categoryName variable in the SQL that wasn't being passed into the function. I’ve made it optional so you can see a report for everything or just one category.

PHP

public static function expenseReportByPeriod(string $userId, string $period = 'month', ?string $categoryName = null) {
    $pdo = DatabaseHelper::getPDOInstance();

    // Determine format for PostgreSQL
    $format = ($period === 'day') ? 'YYYY-MM-DD' : (($period === 'year') ? 'YYYY' : 'YYYY-MM');
    
    $query = "SELECT TO_CHAR(created_at, '$format') as period, SUM(amount) as total 
              FROM Expenses 
              WHERE user_id = :userId";

    $params = [':userId' => $userId];

    // If user wants to filter by category too
    if ($categoryName) {
        $query .= " AND category_name = :catName";
        $params[':catName'] = $categoryName;
    }

    $query .= " GROUP BY period ORDER BY period DESC";

    try {
        $stmt = $pdo->prepare($query);
        $stmt->execute($params);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    } catch (PDOException $e) {
        CLIHelper::error("Report Error: " . $e->getMessage());
        return [];
    }
}


- total spent by year,month and day

- pass variable to hold the date(day,month, year)
- get pdo connect for query execution
- query statment to get the sum amount of all the expenses by the userId, as total spent
- 